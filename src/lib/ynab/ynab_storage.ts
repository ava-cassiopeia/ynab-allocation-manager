import {Injectable, signal, computed, resource, effect} from "@angular/core";
import {AccountType, API, BudgetSummary} from "ynab";

/**
 * Stores cached YNAB data for the application.
 */
@Injectable({providedIn: 'root'})
export class YnabStorage {
  readonly apiKey = signal<string | null>(null);

  readonly api = computed<API | null>(() => {
    const key = this.apiKey();
    if (key === null) return null;

    return new API(key);
  });

  /**
   * A resource which supplies all of the user's budgets, if an appropriate
   * API key is available.
   */
  readonly budgets = resource({
    params: () => ({api: this.api()}),

    loader: async ({params}) => {
      if (params.api === null) return [];

      const response = await params.api.budgets.getBudgets();
      return response.data.budgets;
    },
  });

  /**
   * The budget the user has selected to work on. Null if the user hasn't
   * selected a budget yet.
   */
  readonly selectedBudget = signal<BudgetSummary | null>(null);

  /**
   * A resource which supplies all of the categories for the user's selected
   * budget. Empty if no budget has been selected yet.
   */
  readonly categories = resource({
    params: () => ({
      api: this.api(),
      budget: this.selectedBudget(),
    }),

    loader: async ({params}) => {
      const {api, budget} = params;
      if (api === null) return [];
      if (budget === null) return [];

      const response = await api.categories.getCategories(budget.id);
      return response.data.category_groups
          .filter((g) => !g.deleted && !g.hidden)
          // Special category generated by YNAB automatically that isn't
          // relevant to this application. Sadly, there's no easier way (with
          // the data provided from the API) to identify this category, because
          // it's not considered hidden or deleted, nor does it have a fixed
          // ID between budgets.
          // It's possible this won't work for non-English YNAB budgets, some
          // experimentation might be required here.
          .filter((g) => g.name.trim().toLowerCase() !== "internal master category");
    },
  });

  /**
   * A list of all of the user's accounts for their selected budget, or an empty
   * array if they haven't selected a budget yet.
   */
  readonly accounts = resource({
    params: () => ({
      api: this.api(),
      budget: this.selectedBudget(),
    }),

    loader: async ({params}) => {
      const {api, budget} = params;
      if (api === null) return [];
      if (budget === null) return [];

      const response = await api.accounts.getAccounts(budget.id);
      return response.data.accounts
          // Only show active budget accounts
          .filter((a) => !a.closed)
          .filter((a) => a.on_budget)
          // ...and exclude credit cards, since you can't _really_ just cache
          // money there.
          .filter((a) => a.type !== AccountType.CreditCard);
    },
  });

  constructor() {
    // Attempt to load any saved API key from session storage.
    const storedApiKey = sessionStorage.getItem('ynab.apiKey');
    if (storedApiKey) {
      this.apiKey.set(storedApiKey);
    }

    // Save the provided API key to session storage.
    effect(() => {
      const apiKey = this.apiKey();
      if (apiKey) {
        sessionStorage.setItem('ynab.apiKey', apiKey);
      } else {
        sessionStorage.removeItem('ynab.apiKey');
      }
    });
  }

  reset() {
    this.selectedBudget.set(null);
  }
}
